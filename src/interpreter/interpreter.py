#!/usr/bin/env python3
"""
Trion Language Interpreter

This module implements a tree-walking interpreter for the Trion programming language.
It executes code by traversing the AST generated by the parser.
"""

import sys
import os

# Add the src directory to path so we can import our modules
current_dir = os.path.dirname(os.path.abspath(__file__))
src_dir = os.path.dirname(current_dir)
sys.path.insert(0, src_dir)

from typing import Any, Dict, List, Optional, Union
from lexer.lexer import Token, TokenType, Lexer
from parser.parser import Parser
from syntax_tree.syntax_tree import *

class TrionRuntimeError(Exception):
    """Runtime error during Trion program execution."""
    
    def __init__(self, message: str, location: SourceLocation):
        self.message = message
        self.location = location
        super().__init__(f"Runtime error at {location}: {message}")

class TrionValue:
    """Wrapper for values in the Trion runtime."""
    
    def __init__(self, value: Any, type_name: str):
        self.value = value
        self.type_name = type_name
    
    def __str__(self) -> str:
        return str(self.value)
    
    def __repr__(self) -> str:
        return f"TrionValue({self.value}, {self.type_name})"
    
    def is_truthy(self) -> bool:
        """Determine truthiness of value."""
        if isinstance(self.value, bool):
            return self.value
        elif self.value is None:
            return False
        elif isinstance(self.value, (int, float)):
            return self.value != 0
        elif isinstance(self.value, str):
            return len(self.value) > 0
        return True

class Environment:
    """Environment for variable storage with lexical scoping."""
    
    def __init__(self, enclosing: Optional['Environment'] = None):
        self.enclosing = enclosing
        self.values: Dict[str, TrionValue] = {}
    
    def define(self, name: str, value: TrionValue):
        """Define a new variable in this environment."""
        self.values[name] = value
    
    def get(self, name: str, location: SourceLocation) -> TrionValue:
        """Get a variable from this environment or enclosing ones."""
        if name in self.values:
            return self.values[name]
        
        if self.enclosing:
            return self.enclosing.get(name, location)
        
        raise TrionRuntimeError(f"Undefined variable '{name}'", location)
    
    def assign(self, name: str, value: TrionValue, location: SourceLocation):
        """Assign to an existing variable."""
        if name in self.values:
            self.values[name] = value
            return
        
        if self.enclosing:
            self.enclosing.assign(name, value, location)
            return
        
        raise TrionRuntimeError(f"Undefined variable '{name}'", location)

class TrionFunction:
    """Callable function in Trion."""
    
    def __init__(self, declaration: FunctionDeclaration, closure: Environment):
        self.declaration = declaration
        self.closure = closure
    
    def call(self, interpreter: 'Interpreter', arguments: List[TrionValue]) -> TrionValue:
        """Call this function with given arguments."""
        if len(arguments) != len(self.declaration.parameters):
            raise TrionRuntimeError(
                f"Expected {len(self.declaration.parameters)} arguments but got {len(arguments)}",
                self.declaration.location
            )
        
        # Create new environment for function execution
        environment = Environment(self.closure)
        
        # Bind parameters
        for i, param in enumerate(self.declaration.parameters):
            environment.define(param.name, arguments[i])
        
        try:
            # Execute function body
            interpreter.execute_block(self.declaration.body.statements, environment)
        except ReturnException as ret:
            return ret.value
        
        # No explicit return, return unit value (void)
        return TrionValue(None, "unit")

class ReturnException(Exception):
    """Exception used to implement return statements."""
    
    def __init__(self, value: TrionValue):
        self.value = value

class BreakException(Exception):
    """Exception used to implement break statements."""
    pass

class ContinueException(Exception):
    """Exception used to implement continue statements."""
    pass

class Interpreter(ASTVisitor):
    """Tree-walking interpreter for Trion."""
    
    def __init__(self):
        self.globals = Environment()
        self.environment = self.globals
        self.locals: Dict[Expression, int] = {}
        
        # Define built-in functions
        self._define_builtins()
    
    def _define_builtins(self):
        """Define built-in functions."""
        # println function
        class PrintlnFunction:
            def call(self, interpreter: 'Interpreter', arguments: List[TrionValue]) -> TrionValue:
                output = ' '.join(str(arg.value) for arg in arguments)
                print(output)
                return TrionValue(None, "unit")
        
        self.globals.define("println", TrionValue(PrintlnFunction(), "function"))
    
    def interpret(self, program: Program):
        """Interpret a Trion program."""
        try:
            for statement in program.statements:
                self.execute(statement)
        except TrionRuntimeError as e:
            print(f"Runtime Error: {e}")
            return False
        return True
    
    def execute(self, stmt: Statement):
        """Execute a statement."""
        return stmt.accept(self)
    
    def evaluate(self, expr: Expression) -> TrionValue:
        """Evaluate an expression."""
        return expr.accept(self)
    
    def execute_block(self, statements: List[Statement], environment: Environment):
        """Execute a block of statements in given environment."""
        previous = self.environment
        try:
            self.environment = environment
            
            for statement in statements:
                self.execute(statement)
        finally:
            self.environment = previous
    
    # Visitor methods for literals
    
    def visit_integer_literal(self, node: IntegerLiteral) -> TrionValue:
        return TrionValue(node.value, "i32")
    
    def visit_float_literal(self, node: FloatLiteral) -> TrionValue:
        return TrionValue(node.value, "f64")
    
    def visit_string_literal(self, node: StringLiteral) -> TrionValue:
        return TrionValue(node.value, "str")
    
    def visit_char_literal(self, node: CharLiteral) -> TrionValue:
        return TrionValue(node.value, "char")
    
    def visit_boolean_literal(self, node: BooleanLiteral) -> TrionValue:
        return TrionValue(node.value, "bool")
    
    def visit_identifier(self, node: Identifier) -> TrionValue:
        return self.environment.get(node.name, node.location)
    
    # Visitor methods for expressions
    
    def visit_binary_expression(self, node: BinaryExpression) -> TrionValue:
        left = self.evaluate(node.left)
        right = self.evaluate(node.right)
        
        # Arithmetic operations
        if node.operator == BinaryOperator.ADD:
            if left.type_name in ["i32", "f64"] and right.type_name in ["i32", "f64"]:
                return TrionValue(left.value + right.value, "f64" if "f64" in [left.type_name, right.type_name] else "i32")
            elif left.type_name == "str" or right.type_name == "str":
                return TrionValue(str(left.value) + str(right.value), "str")
            else:
                raise TrionRuntimeError(f"Cannot add {left.type_name} and {right.type_name}", node.location)
        
        elif node.operator == BinaryOperator.SUBTRACT:
            if left.type_name in ["i32", "f64"] and right.type_name in ["i32", "f64"]:
                return TrionValue(left.value - right.value, "f64" if "f64" in [left.type_name, right.type_name] else "i32")
            else:
                raise TrionRuntimeError(f"Cannot subtract {right.type_name} from {left.type_name}", node.location)
        
        elif node.operator == BinaryOperator.MULTIPLY:
            if left.type_name in ["i32", "f64"] and right.type_name in ["i32", "f64"]:
                return TrionValue(left.value * right.value, "f64" if "f64" in [left.type_name, right.type_name] else "i32")
            else:
                raise TrionRuntimeError(f"Cannot multiply {left.type_name} and {right.type_name}", node.location)
        
        elif node.operator == BinaryOperator.DIVIDE:
            if left.type_name in ["i32", "f64"] and right.type_name in ["i32", "f64"]:
                if right.value == 0:
                    raise TrionRuntimeError("Division by zero", node.location)
                return TrionValue(left.value / right.value, "f64")
            else:
                raise TrionRuntimeError(f"Cannot divide {left.type_name} by {right.type_name}", node.location)
        
        elif node.operator == BinaryOperator.MODULO:
            if left.type_name in ["i32", "f64"] and right.type_name in ["i32", "f64"]:
                if right.value == 0:
                    raise TrionRuntimeError("Modulo by zero", node.location)
                return TrionValue(left.value % right.value, "i32" if left.type_name == "i32" and right.type_name == "i32" else "f64")
            else:
                raise TrionRuntimeError(f"Cannot compute modulo of {left.type_name} and {right.type_name}", node.location)
        
        # Comparison operations
        elif node.operator == BinaryOperator.EQUAL:
            return TrionValue(left.value == right.value, "bool")
        
        elif node.operator == BinaryOperator.NOT_EQUAL:
            return TrionValue(left.value != right.value, "bool")
        
        elif node.operator == BinaryOperator.LESS_THAN:
            if left.type_name in ["i32", "f64"] and right.type_name in ["i32", "f64"]:
                return TrionValue(left.value < right.value, "bool")
            else:
                raise TrionRuntimeError(f"Cannot compare {left.type_name} and {right.type_name}", node.location)
        
        elif node.operator == BinaryOperator.LESS_EQUAL:
            if left.type_name in ["i32", "f64"] and right.type_name in ["i32", "f64"]:
                return TrionValue(left.value <= right.value, "bool")
            else:
                raise TrionRuntimeError(f"Cannot compare {left.type_name} and {right.type_name}", node.location)
        
        elif node.operator == BinaryOperator.GREATER_THAN:
            if left.type_name in ["i32", "f64"] and right.type_name in ["i32", "f64"]:
                return TrionValue(left.value > right.value, "bool")
            else:
                raise TrionRuntimeError(f"Cannot compare {left.type_name} and {right.type_name}", node.location)
        
        elif node.operator == BinaryOperator.GREATER_EQUAL:
            if left.type_name in ["i32", "f64"] and right.type_name in ["i32", "f64"]:
                return TrionValue(left.value >= right.value, "bool")
            else:
                raise TrionRuntimeError(f"Cannot compare {left.type_name} and {right.type_name}", node.location)
        
        # Logical operations
        elif node.operator == BinaryOperator.LOGICAL_AND:
            if not left.is_truthy():
                return left
            return right
        
        elif node.operator == BinaryOperator.LOGICAL_OR:
            if left.is_truthy():
                return left
            return right
        
        else:
            raise TrionRuntimeError(f"Unknown binary operator: {node.operator}", node.location)
    
    def visit_unary_expression(self, node: UnaryExpression) -> TrionValue:
        operand = self.evaluate(node.operand)
        
        if node.operator == UnaryOperator.MINUS:
            if operand.type_name in ["i32", "f64"]:
                return TrionValue(-operand.value, operand.type_name)
            else:
                raise TrionRuntimeError(f"Cannot negate {operand.type_name}", node.location)
        
        elif node.operator == UnaryOperator.PLUS:
            if operand.type_name in ["i32", "f64"]:
                return operand
            else:
                raise TrionRuntimeError(f"Cannot apply unary plus to {operand.type_name}", node.location)
        
        elif node.operator == UnaryOperator.LOGICAL_NOT:
            return TrionValue(not operand.is_truthy(), "bool")
        
        else:
            raise TrionRuntimeError(f"Unknown unary operator: {node.operator}", node.location)
    
    def visit_assignment_expression(self, node: AssignmentExpression) -> TrionValue:
        value = self.evaluate(node.value)
        
        if isinstance(node.target, Identifier):
            self.environment.assign(node.target.name, value, node.location)
            return value
        else:
            raise TrionRuntimeError("Invalid assignment target", node.location)
    
    def visit_call_expression(self, node: CallExpression) -> TrionValue:
        callee = self.evaluate(node.callee)
        
        arguments = []
        for arg in node.arguments:
            arguments.append(self.evaluate(arg))
        
        if not hasattr(callee.value, 'call'):
            raise TrionRuntimeError("Not a callable object", node.location)
        
        return callee.value.call(self, arguments)
    
    def visit_member_expression(self, node: MemberExpression) -> TrionValue:
        raise TrionRuntimeError("Member expressions not yet implemented", node.location)
    
    def visit_index_expression(self, node: IndexExpression) -> TrionValue:
        raise TrionRuntimeError("Index expressions not yet implemented", node.location)
    
    # Visitor methods for statements
    
    def visit_expression_statement(self, node: ExpressionStatement):
        self.evaluate(node.expression)
    
    def visit_variable_declaration(self, node: VariableDeclaration):
        value = TrionValue(None, "unit")
        if node.initializer:
            value = self.evaluate(node.initializer)
        
        self.environment.define(node.name, value)
    
    def visit_function_declaration(self, node: FunctionDeclaration):
        function = TrionFunction(node, self.environment)
        self.environment.define(node.name, TrionValue(function, "function"))
    
    def visit_block_statement(self, node: BlockStatement):
        self.execute_block(node.statements, Environment(self.environment))
    
    def visit_if_statement(self, node: IfStatement):
        condition_value = self.evaluate(node.condition)
        
        if condition_value.is_truthy():
            self.execute(node.then_branch)
        elif node.else_branch:
            self.execute(node.else_branch)
    
    def visit_while_statement(self, node: WhileStatement):
        try:
            while self.evaluate(node.condition).is_truthy():
                try:
                    self.execute(node.body)
                except ContinueException:
                    continue
        except BreakException:
            pass
    
    def visit_return_statement(self, node: ReturnStatement):
        value = TrionValue(None, "unit")
        if node.value:
            value = self.evaluate(node.value)
        
        raise ReturnException(value)
    
    def visit_break_statement(self, node: BreakStatement):
        raise BreakException()
    
    def visit_continue_statement(self, node: ContinueStatement):
        raise ContinueException()
    
    def visit_program(self, node: Program):
        for statement in node.statements:
            self.execute(statement)

def main():
    """Test the interpreter with sample code."""
    sample_code = '''
    fn fibonacci(n: i32) -> i32 {
        if n <= 1 {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    fn main() {
        let x: i32 = 10;
        println("Fibonacci of", x, "is", fibonacci(x));
        
        let mut i = 0;
        while i < 5 {
            println("Count:", i);
            i = i + 1;
        }
    }
    
    main();
    '''
    
    try:
        # Tokenize
        lexer = Lexer(sample_code)
        tokens = lexer.tokenize()
        
        # Parse
        parser = Parser(tokens)
        program = parser.parse()
        
        # Interpret
        interpreter = Interpreter()
        interpreter.interpret(program)
        
    except Exception as e:
        print(f"Error: {e}")

if __name__ == '__main__':
    main()